// Сначала у Шляпсика и Бяксика были нормальные одинаковые часы.
// Когда они показывали время t0, Шляпсик решил переводить их на t1 минут
//  вперед каждые 30 минут, а Бяксик стал переводить их на t2 минут назад каждый час
// Написать программу, которая выясняет через сколько суток,
// часы Шляпсика и Бяксика покажут одинаковое время и какое это будет время.
//  Решить задачу, используя класс CTime.


#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

// Описание интерфейса класса Time
class CTime{

// по-умолчанию, атрибуты считаются недоступными
// пользователю. К ним можно обращаться через
// функции, которые будут объявлены доступыми
  int h; // часы, от 0 до 11
  int min; // минуты, от 0 до 59

// объявление открытой области:
// все атрибуты и функции из этой области
// доступны пользвателю объекта
 public:
// Объявление конструктора
   CTime();
// Конструктор всегда имеет имя класса.
// По умолчанию конструктор просто выделяет необходимую
// память  для атрибутов и методов объекта
// но конструктор - тоже функция, и можно
// добавить в него свой код

// объявление методов:
  void setTime(int, int); // установка времени
  void setTimeString(char *);// установка строкой H:MIN
   // Установить время от системных часов
  void setCurrentTime();
  void print(); // печать значений часов
  CTime after(CTime a);// получить показание часов через a

  CTime before(CTime a); // возвращает объект время - показание часов на *a* раньше

  // возвращает 1, если текущее время на циферблате больше аргумента, 0 - если совпадают
  // и -1, если меньше.
  int isLater(CTime);
};

// Конструктор.
  CTime::CTime(){
// конструктор вызывается при создании объетка.
// Пусть атрибуты сразу будут равны 0
  h = 0;
  min = 0;
};

//  печать значений атрибутов
void CTime::print(){
 cout<<h<<':'<<min<<endl;
};

// Установка времени. Будем считать, что минуты не могут
// быть меньше 0 и больше 59, и часы должны быть не меньше 0
void CTime::setTime(int h24, int min24){
// сразу проверяем допустимость значений
// если не правильно - прерываемся
   if(0 > min24 || 59 < min24 || 0 > h24 ){
     cout<<"Неверное время\n";
     exit(1);
   }
   min = min24;
// часы >0 конвертируем.
  h = h24 % 12;
};

// Сумма времен
// Результатм является объект типа CTime
CTime CTime::after(CTime a){
// Чтобы вернуть объект, его нужно иметь
// Создадим временный объект
   CTime tmp;
// так как объекты a и tmp - это объекты класса CTime
// все функции этого класса имеют дрступ ко всем атрибутам этого класса
// Значит эта функция CTime::add() может обращаться к закрытым атрибутам
// объетка a и tmp
   int mins = min + a.min;
   tmp.min = mins % 60;
   tmp.h = (h + a.h + mins / 60) % 24;

   return tmp;
};


void CTime::setCurrentTime(){
  /*
  struct tm
{
  int tm_sec;     // секунды после минут [0,59]
  int tm_min;     // минуты после часов [0,59]
  int tm_hour;    // часы после полуночи [0,23]
  int tm_mday;    // день месяца [1,31]
  int tm_mon;     //// Сумма времен
// Результатм является объект типа CTime
CTime CTime::after(CTime a){
// Чтобы вернуть объект, его нужно иметь
// Создадим временный объект
   CTime tmp;
// так как объекты a и tmp - это объекты класса CTime
// все функции этого класса имеют дрступ ко всем атрибутам этого класса
// Значит эта функция CTime::add() может обращаться к закрытым атрибутам
// объетка a и tmp
   int mins = min + a.min;
   tmp.min = mins % 60;
   tmp.h = (h + a.h + mins / 60) % 24;

   return tmp;
}; месяц года (январь = 0) [0,11]
  int tm_year;    // год (1900 год = 0)
  int tm_wday;    // день недели (вс = 0) [0,6]
  int tm_yday;    // день года (1 января = 0) [0,365]
  int tm_isdst;   // флаг перехода на летнее время (>0- вкл.)
};
*/
  // системная струкура
  struct tm *u;
  const time_t timer = time(NULL);
  u = localtime(&timer);
  h = u -> tm_hour;
  min = u -> tm_min;
};


 void CTime::setTimeString(char * str){
   // Предполагается что пользователь ввел часы в формате 10:55
   // Первые 2 числа - час - сразу берем через atoi()
   h = atoi (str);

   // смещаем исходную строку, Чтобы остановить на минутах
   char * minute = str + 3;

   // указатель на отсальную часть
   // берем минуты. кроме них ничего нет
   min = atoi(minute);
 };


 // Разница времен
 // Результатм является объект типа CTime
 CTime CTime::before(CTime a){
 // Чтобы вернуть объект, его нужно иметь
 // Создадим временный объект
    CTime tmp;
 // так как объекты a и tmp - это объекты класса CTime
 // все функции этого класса имеют дрступ ко всем атрибутам этого класса
 // Значит эта функция CTime::add() может обращаться к закрытым атрибутам
 // объетка a и tmp
    int mins = (min < a.min || min == a.min) * (a.min - min) + (min > a.min) * (min - a.min);
    tmp.min = mins % 60;
    tmp.h = (24 + h - a.h - (min < a.min)) % 24;

    return tmp;
 };


int CTime::isLater(CTime t_t){

  if (h > t_t.h)
    return 1;
  else if(h < t_t.h)
    return -1;
  else if (min > t_t.min)
    return 1;
  else if(min < t_t.min)
    return -1;
  else
    return 0;
};


// Как использовать объект часы:
int main(){

  CTime shlyap_vp; // t1 vpered kazhdie 30min
  CTime byak_nz; // t2 nazad kazhdi 1 chas
  CTime thirty_min;
  CTime one_hour;

  // установка соответствующих часов
  // можно задавать с терминала
  // для тестировки зададим вручную
  shlyap_vp.setTime(0,0);
  byak_nz.setTime(0,0);
  thirty_min.setTime(0,30);
  one_hour.setTime(1,0);

  int i = 0;
  do {
    i++;
    shlyap_vp = shlyap_vp.after(thirty_min);
    byak_nz = byak_nz.before(one_hour);

    shlyap_vp.print();
    byak_nz.print();
    
  } while(shlyap_vp.isLater(byak_nz) != 0);

  cout << i;
   return 0;
}
