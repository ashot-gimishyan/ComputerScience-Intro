#include <iostream>
#include <cstdlib>

using namespace std;
// Класс, в котором есть общие для работников и ворон
// атрибуты и функции

class Person{
  int apple; // яблоки "знают" и работники и вороны
public:
      Person(); // конструктор. Количество яблок - случайно
      Person(int app); // инициализирующий конструктор.
      int getApple(); // возвращает количество яблок
      void print(); // печать

// корзина - статический объект
// в области public, значит ее могут использовать все
      static int basket;
};
// Сначала в козине 0
int Person::basket=0;

// Реализация

Person::Person(){
    //srand(time(0));
    apple=rand() % 100;
//   cout<<"Появился кто-то. Хочет "<<apple<<" яблок в час"<<endl;
};

Person::Person( int app){
// Проверка. Сокращенная запись
// Если app < 0, то яблок - 0, если >=0, то не больше 100
    apple=(app < 0)? 0 : app % 100;
//   cout<<"Появился кто-то. Хочет "<<apple<<" яблок в час"<<endl;
};
// получить яблоки
int Person::getApple(){
     return apple;
};
// печать
void Person::print(){
  cout<<apple<<" яблок в час"<<endl;
// basket - статическая переменная - общая для всех
// сразу печататем сколько в ней яблок
};

// Объявляем класс Worker как наследник
class Worker:public Person{
public:
// Новый конструктор по-умолчанию
      Worker();
// Новый инициализирующий кнструктор
      Worker(int app);
// новая функция, ее не было
      void act();
};

// Реализация

Worker::Worker(){
// в новом конструкторе можно добавить действий
   cout<<"Я работник, я собираю ";
// этот print() уже есть в классе - родителе Person
// его можно просто вызвать.
   print() ;
};

// Новый инициализирующий конструктор
// Когда создается объект класса-наследника, сначала всегда создается
// объект класса - родителя.
// apple - в закрытой области класса-родителя, значит
// не доступен Worker/
// Чтобы передать параметры объекьу классса Person,
// нужно ЯВНО вызвать инициализирующий конструктор класса Person

Worker::Worker(int app):Person(app){
   cout<<"Я работник, мне сказали собирать ";
   print() ;
};

// basket - в открытой области. Можно спокойно им пользоваться
void Worker::act(){
     basket += getApple(); // кладет яблоки в корзину
    // cout << basket << endl;
};

class Crow:public Person{
// про яблоки все уже написано в классе Person
   public:
       Crow(); // конструктор
       Crow(int app); // инициализирующий конструктор
       void steal(); // вороны воруют яблоки из корзины
};

Crow::Crow(){
// в новом конструкторе можно добавить действий
   cout<<"Я ворона, я ворую ";
// этот print() уже есть в классе - родителе Person
// его можно просто вызвать.
   print() ;
};

Crow::Crow(int app):Person(app){
   cout<<"Я ворона, я буду воровать ";
   print() ;
};

// basket - в открытой области. Можно спокойно им пользоваться
void Crow::steal(){
    int n = getApple();
    if (basket > n)
     basket -= n;
    else
      basket = 0;
};

// Пример использования Worker
int main(){
    Worker a[10];
    Crow cr[10];

    for(int h = 0; h < 8; h++)
    {
      for(int i = 0; i < 10; i++)
      {
        a[i].act();
      }

      for (int j = 0; j < 10; j++)
      {
        cr[j].steal();
      }
    }

  std::cout << "В конце дня осталось: " << Person::basket << '\n';
    return 0;

   return 0;
}
