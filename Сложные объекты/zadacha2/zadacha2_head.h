#include <iostream>
#include <cstdlib>

using namespace std;

class Drob{
 int cel, chisl,znam;

public:
  Drob(); // конструктор дроби по-умолчанию
// Инициализирующий конструктор
  Drob(int, int, int);

// Устанавливаем значение
  void setVol(int, int,int);
/*
Зарезервированное слово "operator" обозначает описание именно
оператора, а не какой-либо другой функции.
В С++ существуют два способа передачи адреса: указатель (*) и
ссылка (&).
  При передачи указателя синтаксис работы с этим объектом
как с указателем (разыменовывание - *point, обращение к
атрибутам и методам - point->metod()).

  При передачи ссылки сохраняется синтаксис как при работе с
самим объектом: разыменовывание не нужно.

Но объявить ссылку как отдельный объект нельзя. Она
используется только для передачи данных в функции и как
возвращаемые значения функций.

При передачи адреса есть опасность несанкционированно
изменить значение объекта. Чтобы этого не произошло,
объявляется const. Тогда такие попытки будут отловлены на
стадии компиляции.

*/
  Drob operator+(const Drob&);
  Drob operator-(const Drob&);
  Drob operator*(const Drob&);
  Drob operator/(const Drob&);
  int operator>(const Drob&);
  int operator<(const Drob&);
  int operator==(const Drob&);

/*
  Оператор ++ - постфиксный, то есть пишется после объекта.
Поэтому для соблюдений правил синтаксиса ему нужно указать
неиспользуемый параметр int

Так как этот оператор изменяет текущий объект, он возвращает
указатель на себя самого. Для того, чтобы иметь указатель на текущий
объект, имеется специальное слово this.
*/
  Drob& operator++(int);


/*
  Оператор ! - префиксный, то есть пишется перед объектом.
Ему не нужно указывать дополнительный параметр, так как сам
объект формально является его параметром.

  Для всех операторов существует строго определенное количество
параметров, а для некоторых параметров еще должен сохраняться его
тип. Переопределяя оператор, нельзя изменить количество параметров
для этого оператора (а для некоторых еще и тип). Переопределению
подлежит, в основном, функциональность.
*/

  Drob& operator!();

// Для отладки
  void print();
  void print(char);
  void print(int);
  int NOD(int, int);
};
